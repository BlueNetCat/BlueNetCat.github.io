<html>
    <head>
        <script src='./grib2.js'></script>

    </head>
    <body>
        <script>




let myBuffer = null;
let gribFiles = [];

//fetch('COSMODE_single_level_elements_PS_2018020500_000.grib2')
//fetch('COSMODE_single_level_elements_ASWDIR_S_2018011803_006.grib2')
fetch('gdas.t00z.pgrb2.1p00.f000.grib2')
    .then(response => response.arrayBuffer())
    .then(buffer => decodeGRIB2File(buffer))
    .catch(error => console.log(error));


const decodeGRIB2File = function(buffer){
    myBuffer = buffer;

    let gribByteIndex = 0;
    let gribFileBuffers = [];

    // Separate GRIB buffers
    while (gribByteIndex < buffer.byteLength){
        // Get Total GRIB length from buffer
        let gribLength = new DataView(buffer.slice(gribByteIndex + 12, gribByteIndex + 16)).getInt32();
        gribFileBuffers.push(buffer.slice(gribByteIndex, gribByteIndex + gribLength));
        gribByteIndex += gribLength;
    }

    // Iterate over GRIB buffers
    for (let i = 0; i < gribFileBuffers.length; i++){
        gribFiles[i] = new GRIB2(gribFileBuffers[i]);
        decodeGRIB2Buffer(gribFileBuffers[i], gribFiles[i]);
    }
}



const decodeGRIB2Buffer = function(buffer, myGrib){

    
    // Section 0 - Indicator Section
    let sectionHeader = buffer.slice(0,16);
    decodeSection(sectionHeader, myGrib.dataTemplate[0]);

    // Separate section buffers
    let sectionByteIndex = 16;
    let sectionBuffers = myGrib.sectionBuffers;

    while (sectionByteIndex < buffer.byteLength){
        // Get Total GRIB length from buffer
        let sectionLength = new DataView(buffer.slice(sectionByteIndex, sectionByteIndex + 4)).getInt32();
        sectionBuffers.push(buffer.slice(sectionByteIndex, sectionByteIndex + sectionLength));
        sectionByteIndex += sectionLength;
    }

    // Decode section buffers
    for (let i = 0; i < sectionBuffers.length - 1; i++){ // (length - 1) because of end section has 4 bytes only (7777)
        let sectionNumber = new DataView(sectionBuffers[i].slice(4, 5)).getInt8();
        myGrib.dataTemplate[sectionNumber] = decodeSection(sectionBuffers[i], myGrib.dataTemplate[sectionNumber]);
    }
   
    console.log(myGrib.dataTemplate);

    let data = parseData(myGrib.dataTemplate);
    console.log(data);

}



// Parse data
const parseData = function(decodedGrib){


    let data = {};

    let grid = {};

    grid.numPoints = getContentByInfo(decodedGrib[3],'Number of data points');

    grid.numLatPoints = getContentByInfo(decodedGrib[3],'Ni — number of points along a parallel');
    grid.numLongPoints = getContentByInfo(decodedGrib[3],'Nj — number of points along a meridian');
    
    grid.latStart = getContentByInfo(decodedGrib[3],'La1 — latitude of first grid point (see Note 1)') / 1e6;
    grid.lonStart = getContentByInfo(decodedGrib[3],'Lo1 — longitude of first grid point (see Note 1)') / 1e6;

    grid.latEnd = getContentByInfo(decodedGrib[3],'La2 — latitude of last grid point (see Note 1)') / 1e6;
    grid.lonEnd = getContentByInfo(decodedGrib[3],'Lo2 — longitude of last grid point (see Note 1)') / 1e6;

    grid.incI = getContentByInfo(decodedGrib[3],'Di — i direction increment (see Notes 1 and 5)') / 1e6;
    grid.incJ = getContentByInfo(decodedGrib[3],'Dj — j direction increment (see Note 1 and 5)') / 1e6;

    data.grid = grid;
    console.log(grid);


    // Data compression scheme (Template 5.x)
    let item = decodedGrib[5].find(item => 'template' in item);
    let template = item !== undefined ? item.template : 'none';

    let compression = {};
    compression.refValue = getContentByInfo(decodedGrib[5], 'Reference value (R) (IEEE 32-bit floating-point value)');
    compression.binaryScaleFactor = getContentByInfo(decodedGrib[5], 'Binary scale factor (E)');
    compression.decimalScaleFactor = getContentByInfo(decodedGrib[5], 'Decimal scale factor (D)');
    compression.bitsPerValue = getContentByInfo(decodedGrib[5], 'Number of bits used for each packed value for simple packing, or for each group reference value for complex packing or spatial differencing');

    compression.decompress = (rawValue => {
        const c1 = Math.pow(2, compression.binaryScaleFactor)
        const c2 = Math.pow(10, compression.decimalScaleFactor)
        return (compression.refValue + rawValue * c1) / c2;
    });

    data.compression = compression;


    
    let rawData = decodedGrib[7][2].content;
    let values = [];

 


    // Grid point data - simple packing
    // https://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_doc/grib2_temp5-0.shtml
    if (template == '5.0'){
        // Should be the same number
        console.log("Bit length/bits per point : " + (rawData.byteLength*8/compression.bitsPerValue) + ", Num points: " + grid.numPoints);
        // Read bits
        values = readValuesFromBuffer(rawData, compression.bitsPerValue, grid.numPoints);
        // Decompress
        for (let i = 0; i < values.length; i++)
            values[i] = compression.decompress(values[i]);
        
            
    } 
    // Grid point data - complex packing
    // https://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_doc/grib2_temp5-2.shtml
    else if (template == '5.2'){ // TODO: TEST
        let NG = getContentByInfo(decodedGrib[5], 'NG ― number of groups of data values into which field is split');

        let xxIndex = Math.ceil(NG*compression.bitsPerValue/8);
        // Group reference values (X1)
        let X1 = readValuesFromBuffer(rawData.slice(0, xxIndex), compression.bitsPerValue, NG);

        let yyIndex = xxIndex*2;
        // Group widths (The group width is the number of bits used for every value in a group.)
        let bitsPerValueGroupWidth = getContentByInfo(decodedGrib[5], 'Number of bits used for the group widths (after the reference value in octet 36 has been removed');
        let groupWidths = readValuesFromBuffer(rawData.slice(xxIndex, yyIndex), bitsPerValueGroupWidth, NG);

        let zzIndex = yyIndex + xxIndex;
        // Scaled group lengths
        let bitsPerValueScaledGL = getContentByInfo(decodedGrib[5], 'Number of bits used for the scaled group lengths (after subtraction of the reference value given in octets 38-41 and division by the length increment given in octet 42)');
        let scaledGroupLengths = readValuesFromBuffer(rawData.slice(yyIndex, zzIndex), bitsPerValueScaledGL, NG);

        // Group lengths (The group length (L) is the number of values in a group.)
        let groupLengths = [];
        let refGroupLength = getContentByInfo(decodedGrib[5], 'Reference for group lengths (see Note 13)');
        let lengthInc = getContentByInfo(decodedGrib[5], 'Length increment for the group lengths (see Note 14)');
        for (let i = 0; i < NG; i++)
            groupLengths[i] = refGroupLength + scaledGroupLengths[i]*lengthInc;
        
        // Packed values (X2)
        let lastBitIndex = 0;
        let lastByteIndex = zzIndex;
        for (let i = 0; i < NG; i++){
            let numValuesPerGroup = groupLengths[i]; // Values per group
            let bitsPerValuePerGroup = groupWidths[i]; // Bits per value in group
            let numBytes = Math.ceil( ((numValuesPerGroup * bitsPerValuePerGroup) + lastBitIndex) / 8); // Total num bits + previous shift amount
            let X2PerGroup = readValuesFromBuffer(rawData.slice(lastByteIndex, lastByteIndex + numBytes), bitsPerValuePerGroup, numValuesPerGroup, lastBitIndex); // Because X2 are consecutive, we keep lastBitIndex
            lastBitIndex = ((numValuesPerGroup * bitsPerValuePerGroup) + lastBitIndex) % 8; // LastBitIndex goes from 0 to 7, as every iteration we send the specific bytes to read.

            // Unpack values
            // Add ref value (X1) to packed values (X2)
            for (let j = 0; j < numValuesPerGroup; j++){
                let rawValue = X2PerGroup[j] + X1[i];
                values.push(compress.decompress(rawValue));
            }
        }
        
    }
    // Grid point data - complex packing and spatial differencing
    // https://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_doc/grib2_temp5-3.shtml
    // https://www.nco.ncep.noaa.gov/pmb/docs/grib2/grib2_doc/grib2_temp7-3.shtml
    // https://apps.ecmwf.int/codes/grib/format/grib2/regulations/
    else if (template == '5.3'){
        // Spatial differencing order
        let diffOrder = getContentByInfo(decodedGrib[5], 'Order of spatial difference (see Code Table 5.6)'); // WARNING --> IF CODE TABLE IS USED, THIS IS A STRING. OTHERWISE 1= 1ST ORDER, 2= SECOND ORDER
        // Field width (Number of bytes for the first values)
        let fieldWidth = getContentByInfo(decodedGrib[5], 'Number of octets required in the data section to specify extra descriptors needed for spatial differencing (octets 6-ww in data template 7.3)');

        
        // First value(s) of original (undifferenced) scale values, followed by the overall minimum of the differences.
        let numType;
        if ( fieldWidth == 1) // Int8
            numType = 'int8';
        else if (fieldWidth == 2) // Int16
            numType = 'int16';
        else if (fieldWidth == 4) // Int32
            numType = 'int32';
        else
            console.error("Field width is not reasonable (func parseData, template 5.3)");

        // For second order
        let f1 = decodeByte(rawData.slice(0, fieldWidth), numType);
        let f2 = decodeByte(rawData.slice(fieldWidth, fieldWidth*2), numType); // Not used if difference order is 1
        let overallMin = decodeByte(rawData.slice(fieldWidth*diffOrder, fieldWidth * (diffOrder+1)), numType);


        // Unpack Complex Packing
        let wwIndex = fieldWidth * (diffOrder + 1);
        let upX1X2 = unpackComplexPacking(decodedGrib, rawData, compression, wwIndex);

        // Decoding (f - original, g - first derivative, h - second derivative)
        let f = [];
        let g = [];
        let h = [];

        // First values
        f.push(f1);
        
        // Second order
        if (diffOrder == 2){
            f.push(f2);

            h[0] = f[0];
            h[1] = f[1];

            // H values
            for (let i = 0; i < upX1X2.NG; i++){
                let numValuesPerGroup = upX1X2.groupLengths[i]; // Values per group
                for (let j = 0; j < numValuesPerGroup; j++){
                    let rawValue = upX1X2.X2[i][j] + upX1X2.X1[i];
                    if (isNaN(rawValue))
                        console.error("rawValue is NaN"); // numValuesPerGroup is 1, but X2 is empty?
                    h.push(rawValue);
                }
            }

            if (grid.numPoints != h.length)
                console.error("Length of raw datapoints (H) is not equal to grid points : grid.numPoints: " + grid.numPoints + ", h.length: " + h.length);
            // G values
            g[0] = f[0];
            g[1] = f[1];// - f[0];
            //g[2] = h[2] + g[1];
            //g[3] = h[3] + g[2];
            for (let i = 2; i < grid.numPoints; i++){
                g[i] = h[i] + g[i-1];
            }
            
            // F values
            //f[2] = g[2] + f[1];
            //f[3] = g[3] + f[2];
            for (let i = 2; i < grid.numPoints; i++){
                f[i] = g[i] + f[i-1];
            }

            for (let i = 0; i < grid.numPoints; i++){
                values[i] = compression.decompress(h[i]);
            }
        }
        
        

        


        var a  = 0;
    }
    
    data.values = values;

    for (var i = 0; i< 10; i++){
        let byteContent = decodedGrib[7][2].content.slice(i*2, i*2 + 2);
        console.log(compression.decompress(new DataView(byteContent).getUint16()));
    }

    return data;
}



// TODO: SOMETHING WRONG! CHECK SIZE OF X2, IT SHOULD BE THE SAME AS NUMBER OF GRID POINTS-2
// Unpack values (templates 5.2 and 5.3)
const unpackComplexPacking = function(decodedGrib, rawData, compression, inPrevIndex){

    let prevIndex = inPrevIndex || 0;

    let NG = getContentByInfo(decodedGrib[5], 'NG ― number of groups of data values into which field is split');

    let xxIndex = Math.ceil(NG*compression.bitsPerValue/8) + prevIndex;
    // Group reference values (X1)
    let X1 = readValuesFromBuffer(rawData.slice(prevIndex, xxIndex), compression.bitsPerValue, NG);

    // Group widths (The group width is the number of bits used for every value in a group.)
    let bitsPerValueGroupWidth = getContentByInfo(decodedGrib[5], 'Number of bits used for the group widths (after the reference value in octet 36 has been removed)');
    let yyIndex = Math.ceil(NG * bitsPerValueGroupWidth/8) + xxIndex;
    let groupWidths = readValuesFromBuffer(rawData.slice(xxIndex, yyIndex), bitsPerValueGroupWidth, NG);

    
    // Scaled group lengths
    let bitsPerValueScaledGL = getContentByInfo(decodedGrib[5], 'Number of bits used for the scaled group lengths (after subtraction of the reference value given in octets 38-41 and division by the length increment given in octet 42)');
    let zzIndex = Math.ceil(NG * bitsPerValueScaledGL/8) + yyIndex;
    let scaledGroupLengths = readValuesFromBuffer(rawData.slice(yyIndex, zzIndex), bitsPerValueScaledGL, NG);

    // Group lengths (The group length (L) is the number of values in a group.)
    let groupLengths = [];
    let refGroupLength = getContentByInfo(decodedGrib[5], 'Reference for group lengths (see Note 13)');
    let lengthInc = getContentByInfo(decodedGrib[5], 'Length increment for the group lengths (see Note 14)');
    for (let i = 0; i < NG; i++)
        groupLengths[i] = refGroupLength + scaledGroupLengths[i]*lengthInc;

    
    // Calculate total number of bytes
    let totalNumBytes = 0;
    let totalNumBits = 0;
    let totalNumPoints = 0;
    for (let i = 0; i < NG; i++) {
        totalNumBits += groupLengths[i] * groupWidths[i];
        totalNumPoints += groupLengths[i];
    }
    console.log("Total number of required bytes: " + totalNumBits/8 + ", Available bytes: " + rawData.byteLength + ", Total number of points: " + totalNumPoints);
    
    // Packed values (X2)
    let lastBitIndex = 0;
    let lastByteIndex = zzIndex;
    let X2 = [];
    for (let i = 0; i < NG; i++){
        let numValuesPerGroup = groupLengths[i]; // Values per group
        let bitsPerValuePerGroup = groupWidths[i]; // Bits per value in group
        if (bitsPerValuePerGroup == 0)
            console.error("An empty group in X2, with no bits is defined? " + i)

        let numBytes = Math.ceil( ((numValuesPerGroup * bitsPerValuePerGroup) + lastBitIndex) / 8); // Total num bits + previous shift amount
        X2[i] = readValuesFromBuffer(rawData.slice(lastByteIndex, lastByteIndex + numBytes), bitsPerValuePerGroup, numValuesPerGroup, lastBitIndex); // Because X2 are consecutive, we keep lastBitIndex
        lastBitIndex = ((numValuesPerGroup * bitsPerValuePerGroup) + lastBitIndex) % 8; // LastBitIndex goes from 0 to 7, as every iteration we send the specific bytes to read.

        // Unpack values
        // Add ref value (X1) to packed values (X2)
        /*for (let j = 0; j < numValuesPerGroup; j++){
            let rawValue = X2[i][j] + X1[i];
            values.push(compress.decompress(rawValue));
        }*/
    }

    return {
        NG: NG,
        X1: X1,
        X2: X2,
        groupLengths: groupLengths,
    }
}










// Read values coded into bits on a buffer
const readValuesFromBuffer = function(arraybuffer, bitsPerValue, numValues, inBitIndex){
    let values = [];
    let bitIndex = inBitIndex || 0;
    const rawUint8 = new Uint8Array(arraybuffer);
    // https://hacks.mozilla.org/2017/01/typedarray-or-dataview-understanding-byte-order/
    // The order of the bytes for a value that uses more than one byte, depends on the way binary data is enconded (its endianess)
    // Big endian or network endian: it is often used in network transmissions (sometimes referred to as the “network endianness”)
    // Small endian: most systems today happen to work with it on the CPU- and memory levels, and that’s great for performance.

    // DataView uses big endian or network endianess: is a safe way to deal with binary data that you receive from or send to other systems.
    // TypedArrays (i.e. new Uint8Array) uses small endian in this computer: are great for creating binary data, for instance to pass on to Canvas2D ImageData or WebGL.
    // grib2 is in big endian? https://www.cpc.ncep.noaa.gov/products/wesley/wgrib2/
    
    // Example
    //var a = new Uint16Array(arraybuffer.slice(0,2)); // small endian
    //var b = new DataView(arraybuffer).getUint16(); // big endian
    //var c = bits2num(bytes2bits(new Uint8Array(arraybuffer.slice(0,2))));
    //console.log("Small endian uint16: " + a + ", Big endian uint16: " + b + ", Using strings: " + c); 


    // If you are out of bounds
    if ((bitsPerValue*numValues + bitIndex)/8 > rawUint8.length)
        console.error("Num required bytes: " + (bitsPerValue*numValues + bitIndex)/8 + ", Num available bytes: " + rawUint8.length);

    // This method does not work properly (or at least differently from when using bit strings)
    // When bits per value are not 8, 16 or 32.
    /*for (let i = 0; i < numValues; i++){
        // Number of bytes (octets) in the raw array that contain the bit information
        let numBytes = Math.ceil((bitIndex % 8 + bitsPerValue) / 8);
        
        let value = 0; // Variable for bit operations (int32 because of javascript limitations)
        let mostSignificantBit = bitsPerValue; // Most significant bit that the byte contains
        for (let j = 0; j < numBytes; j++){ // Iterate the bytes
            let tmp = rawUint8[Math.floor(bitIndex/8)]; // Get the int8 value
            let shiftAmount = mostSignificantBit - (8 - bitIndex % 8); // Get the bit shifting operation
            // Shift bits to the left (adds zeros on the right)
            if (shiftAmount > 0){
                // Clean most significant bits
                tmp = tmp << (32 - shiftAmount); 
                tmp = tmp >>> (32 - shiftAmount)
                // Shift
                tmp = tmp << shiftAmount;
                bitIndex += (8 - bitIndex % 8); // Increase bitIndex
                mostSignificantBit = shiftAmount;
            }
            // Shifts bits to the right (adds zeros on the left)
            // Ending byte (all remaining bits are in this byte)
            else { 
                if (bitsPerValue < 8){ // There is a need to clean the most significant bits, as they don't belong to the value
                    tmp = tmp << (32 - bitsPerValue) + shiftAmount; 
                    tmp = tmp >>> (32 - bitsPerValue) + shiftAmount; // Unsigned integer
                }
                tmp = tmp >>> -shiftAmount; // Unsigned integer
                bitIndex += mostSignificantBit;
            }

            value = value | tmp; // Binary addition
        }

        values[i] = value;
    }*/

    // Test with string values
    var values2ndmethod = [];
    var bitsString = bytes2bits(rawUint8);
    bitsString = bitsString.slice(bitIndex);
    for (var i = 0; i < numValues * bitsPerValue; i += bitsPerValue)
        values2ndmethod.push(bits2num(bitsString.substr(i, bitsPerValue)));

    //for (var i = 0; i < numValues; i++)
    //    console.log(values[i] - values2ndmethod[i])
    
    return values2ndmethod;
}





// Get content by infoValue
const getContentByInfo = function(sectionArray, infoValue){
    for (let i = 0; i < sectionArray.length; i++){
        if (sectionArray[i].info === infoValue)
            return sectionArray[i].content;
    }
}









// Decode section
const decodeSection = function(buffer, section){

    for (let i = 0; i < section.length; i++){
        let prop = section[i];


        // Variable section content
        // Part of the section might depends on an external template
        if ("templateRef" in prop) {
            // Get template info
            let templateId;
            // Find section item with such startIndex (templateRef is defined at the end of the section)
            for (let j = 0; j < i; j++)
                if (section[j].startIndex == prop.templateRef.index)
                    templateId = prop.templateRef.section + '.' + section[j].content;
            // Assign template to section
            section = section.slice(0, i); // Remove from here to end of section // TODO SECTION 3 DO NOT REMOVE, ONLY APPEND
            try{
                section = section.concat(JSON.parse(JSON.stringify(GRIB2.templates[templateId]))); // Copy template
            }
            catch(error){
                console.log(templateId + " is not defined.")
                console.log(error);
            }
            // Store template id
            section[i].template = templateId;
            // Assign new prop
            prop = section[i];
            console.log("Using template: " + templateId);
        }


        // Variable startIndex
        if (typeof(prop.startIndex) === 'string'){
            if (prop.startIndex === 'nextAvailable'){
                prop.startIndex = section[i-1].startIndex + section[i-1].size;
            }
        }
        
        // Variable content size
        if (typeof(prop.size) === 'string'){ 
            if (prop.size === 'end'){ // From start index to the end of the section
                let sectionSize = section[0].content;
                prop.size = sectionSize - (prop.startIndex - 1);
            } 
            else if (prop.size === 'calc'){ // TODO TEST
                // Get value from section
                let value;
                // Find section item with such startIndex (templateRef is defined at the end of the section)
                for (let j = 0; j < i; j++)
                    if (section[j].startIndex == prop.sizeRef.index)
                        prop.size = prop.sizeRef.calc(value);
                
            }
        }

        

        // Decode bytes
        let byteContent = buffer.slice(prop.startIndex-1, prop.startIndex-1 + prop.size);
        prop.content = decodeByte(byteContent, prop.type)
        /*if (byteContent.byteLength == 0)
            prop.content = null;
        else if (prop.type === 'String')
            prop.content = String.fromCharCode.apply(null, new Uint8Array(byteContent));
        else if (prop.type == 'uint8')
            prop.content = new DataView(byteContent).getUint8();
        else if (prop.type == 'uint16')
            prop.content = new DataView(byteContent).getUint16();
        else if (prop.type == 'uint32')
            prop.content = new DataView(byteContent).getUint32();
        else if (prop.type == 'uint64')
            prop.content = Number(new DataView(byteContent).getBigUint64());

        else if (prop.type == 'int8')
            prop.content = new DataView(byteContent).getInt8();
        else if (prop.type == 'int16')
            prop.content = new DataView(byteContent).getInt16();
        else if (prop.type == 'int32')
            prop.content = new DataView(byteContent).getInt32();
        else if (prop.type == 'int64')
            prop.content = Number(new DataView(byteContent).getBigInt64());

        else if (prop.type == 'float32')
            prop.content = new DataView(byteContent).getFloat32();
        else
            prop.content = byteContent;*/

        // Decode table content
        if ("table" in prop){
            prop.contentRef = GRIB2.tables[prop.table][prop.content];
        }

    }

    return section;
}






function decodeByte(byteContent, type){
    if (byteContent.byteLength == 0)
        content = null;
    else if (type === 'String')
        content = String.fromCharCode.apply(null, new Uint8Array(byteContent));
    else if (type == 'uint8')
        content = new DataView(byteContent).getUint8();
    else if (type == 'uint16')
        content = new DataView(byteContent).getUint16();
    else if (type == 'uint32')
        content = new DataView(byteContent).getUint32();
    else if (type == 'uint64')
        content = Number(new DataView(byteContent).getBigUint64());

    else if (type == 'int8')
        content = new DataView(byteContent).getInt8();
    else if (type == 'int16')
        content = new DataView(byteContent).getInt16();
    else if (type == 'int32')
        content = new DataView(byteContent).getInt32();
    else if (type == 'int64')
        content = Number(new DataView(byteContent).getBigInt64());

    else if (type == 'float32')
        content = new DataView(byteContent).getFloat32();
    else
        content = byteContent;

    return content;
}



// Utility functions
// bytes are in uint8 form
function bytes2bits(bytes)
{
    let bits = "";
    for (let i = 0; i < bytes.length; i++){
        let byte = bytes[i];
        for(let j = 128; j >= 1; j /= 2)
            bits += byte & j ? '1':'0';
    }
    return bits;
}
// Returns unsigned int
function bits2num(bits){
    let value = 0;
    for (let i = 0; i < bits.length; i++)
        value += parseInt(bits[bits.length - (i+1)]) ? Math.pow(2, i) : 0;
    return value;
}




        </script>
    </body>
</html>