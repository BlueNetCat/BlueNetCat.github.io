<html>
    <head>
        <script src='./grib2.js'></script>

    </head>
    <body>
        <script>




let myBuffer = null;
let gribFiles = [];

//fetch('COSMODE_single_level_elements_PS_2018020500_000.grib2')
//fetch('COSMODE_single_level_elements_ASWDIR_S_2018011803_006.grib2')
fetch('gdas.t00z.pgrb2.1p00.f000.grib2')
    .then(response => response.arrayBuffer())
    .then(buffer => decodeGRIB2File(buffer))
    .catch(error => console.log(error));


const decodeGRIB2File = function(buffer){
    myBuffer = buffer;

    let gribByteIndex = 0;
    let gribFileBuffers = [];

    // Separate GRIB buffers
    while (gribByteIndex < buffer.byteLength){
        // Get Total GRIB length from buffer
        let gribLength = new DataView(buffer.slice(gribByteIndex + 12, gribByteIndex + 16)).getInt32();
        gribFileBuffers.push(buffer.slice(gribByteIndex, gribByteIndex + gribLength));
        gribByteIndex += gribLength;
    }

    // Iterate over GRIB buffers
    for (let i = 0; i < gribFileBuffers.length; i++){
        gribFiles[i] = new GRIB2(gribFileBuffers[i]);
        decodeGRIB2Buffer(gribFileBuffers[i], gribFiles[i]);
    }
}



const decodeGRIB2Buffer = function(buffer, myGrib){

    
    // Section 0 - Indicator Section
    let sectionHeader = buffer.slice(0,16);
    parseSection(sectionHeader, myGrib.dataTemplate[0]);

    // Separate section buffers
    let sectionByteIndex = 16;
    let sectionBuffers = myGrib.sectionBuffers;

    while (sectionByteIndex < buffer.byteLength){
        // Get Total GRIB length from buffer
        let sectionLength = new DataView(buffer.slice(sectionByteIndex, sectionByteIndex + 4)).getInt32();
        sectionBuffers.push(buffer.slice(sectionByteIndex, sectionByteIndex + sectionLength));
        sectionByteIndex += sectionLength;
    }

    // Parse section buffers
    for (let i = 0; i < sectionBuffers.length - 1; i++){ // (length - 1) because of end section has 4 bytes only (7777)
        let sectionNumber = new DataView(sectionBuffers[i].slice(4, 5)).getInt8();
        myGrib.dataTemplate[sectionNumber] = parseSection(sectionBuffers[i], myGrib.dataTemplate[sectionNumber]);
    }
   
    console.log(myGrib.dataTemplate);
    console.log(myGrib.sectionBuffers);
}




// Parse section
const parseSection = function(buffer, section){

    for (let i = 0; i < section.length; i++){
        let prop = section[i];


        // Variable section content
        // Part of the section might depends on an external template
        if ("templateRef" in prop) {
            // Get template info
            let templateId;
            // Find section item with such startIndex (templateRef is defined at the end of the section)
            for (let j = 0; j < i; j++)
                if (section[j].startIndex == prop.templateRef.index)
                    templateId = prop.templateRef.section + '.' + section[j].content;
            // Assign template to section
            section = section.slice(0, i); // Remove from here to end of section // TODO SECTION 3 DO NOT REMOVE, ONLY APPEND
            section = section.concat(JSON.parse(JSON.stringify(GRIB2.templates[templateId]))); // Copy template
            // Assign new prop
            prop = section[i];
            console.log("Using template: " + templateId);
        }


        // Variable startIndex
        if (typeof(prop.startIndex) === 'string'){
            if (prop.startIndex === 'nextAvailable'){
                prop.startIndex = section[i-1].startIndex + section[i-1].size;
            }
        }
        
        // Variable content size
        if (typeof(prop.size) === 'string'){ 
            if (prop.size === 'end'){ // From start index to the end of the section
                let sectionSize = section[0].content;
                prop.size = sectionSize - (prop.startIndex - 1);
            } 
            else if (prop.size === 'calc'){ // TODO TEST
                // Get value from section
                let value;
                // Find section item with such startIndex (templateRef is defined at the end of the section)
                for (let j = 0; j < i; j++)
                    if (section[j].startIndex == prop.sizeRef.index)
                        prop.size = prop.sizeRef.calc(value);
                
            }
        }

        

        // Parse bytes
        let byteContent = buffer.slice(prop.startIndex-1, prop.startIndex-1 + prop.size);
        if (byteContent.byteLength == 0)
            prop.content = null;
        else if (prop.type === 'String')
            prop.content = arraybufferToString(byteContent)
        else if (prop.type == 'int8')
            prop.content = new DataView(byteContent).getInt8();
        else if (prop.type == 'int16')
            prop.content = new DataView(byteContent).getInt16();
        else if (prop.type == 'int32')
            prop.content = new DataView(byteContent).getInt32();
        else
            prop.content = byteContent;

        // Parse table content
        if ("table" in prop){
            prop.contentRef = GRIB2.tables[prop.table][prop.content];
        }

    }

    return section;
}




// Transform string
const arraybufferToString = function(buffer){
    return String.fromCharCode.apply(null, new Uint8Array(buffer))
}




        </script>
    </body>
</html>